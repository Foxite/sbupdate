#!/bin/bash

declare -r _f_config=%CONFIG%
declare -r _f_functions=functions

_f_key='' _f_cert=''
_f_efi='' _f_dest=''
_f_initramfs=''
_d_boot=''

_efitype=''
_kernel=''
_cmdline='' _uki=''

_ukify=''

declare -A EXTRA_SIGN

get_kernel() {
    local file
    local -i kernel="$1"

    file="${_f_efi##*/}"

    for kernel in "${file#vmlinuz-}" "$file"; do
        if in_array "$kernel" "${KERNELS[@]}"; then
            return 0
        fi
    done

    return 1
}

enable_extra_sign() {
    local quiet="$1" units=()

    if (( SBUPDATE_EXTRA_SIGN )); then
        return 0
    fi

    systemctl --quiet disable --now "sbupdate@.path"

    for file in "${!EXTRA_SIGN[@]}"; do
        local escaped

        escaped="$(systemd-escape --path "$file")"
        units+=("sbupdate@${escaped}.path")
    done

    systemctl "$quiet" enable --now "${units[@]}"
}

cleanup() {
    exit "$1"
}

# shellcheck disable=SC1090
. "$_f_functions"

if [[ -t 1 ]]; then
    try_enable_color
fi

# shellcheck disable=SC1091 source=sbupdate.conf
. "$_f_config" || die "Failed to read config file '%s'" "$_f_config"

[[ -d "$KEY_DIR" ]] || die "KEY_DIR '%s' doesn't exist or isn't a directory" "$KEY_DIR"

_f_key="$KEY_DIR/DB.key" _f_cert="$KEY_DIR/DB.crt"
[[ -f "$_f_key" && -f "$_f_cert" ]] || die "Cannot find Secure Boot key (DB.key) or cert (DB.crt) under KEY_DIR."

if [[ "$1" ]]; then
    enable_extra_sign --quiet
else
    if [[ -v KERNELDESTINATION ]]; then
        exit 0
    fi

    enable_extra_sign
    exit
fi

_f_efi="$1"
[[ -f "$_f_efi" ]] || die "EFI binary '%s' doesn't exist" "$_f_efi"

_efitype="$(bootctl kernel-identify "$_f_efi" 2>/dev/null)"
[[ "$_efitype" == "pe" ]] || die "'%s' isn't a valid EFI binary" "$_f_efi"

if (( SBUPDATE_EXTRA_SIGN )); then
    _f_dest="${EXTRA_SIGN["$_f_efi"]}"
    if [[ "$_f_dest" ]]; then
        sbsign --key "$_f_key" --cert "$_f_cert" --output "$_f_dest" "$_f_efi"
        exit
    else
        die "Requested for EXTRA_SIGN but file '%s' isn't listed" "$_f_efi"
    fi
fi

_d_boot="$(bootctl --print-boot-path 2>/dev/null)"
[[ -d "$_d_boot" ]] || die "Failed to locate ESP or XBOOTLDR"

get_kernel "_kernel" || msg "Kernel '%s' isn't configured in config '%s'" "$_f_efi" "$_f_config"
_f_initramfs="$2"

set -e

declare -i _config="$_kernel"

if [[ ! -v "_config[uki-fallback]" ]]; then
    if [[ "$_f_initramfs" == *-fallback.img ]]; then
        exit 0
    fi

    if [[ -v "_config[uki]" ]]; then
        _uki="${_config[uki]}"
    else
        _uki="${_kernel#vmlinuz-}${UKI_SUFFIX}"
    fi
else
    _uki="${_config[uki-fallback]}"
fi

if [[ -v "_config[cmdline]" ]]; then
    _cmdline="${_config[cmdline]} $CMDLINE_ALWAYS"
else
    _cmdline="$CMDLINE_DEFAULT $CMDLINE_ALWAYS"
fi

mkdir -p "$_d_boot/$UKI_DIR"
_f_dest="$_d_boot/$UKI_DIR/$_uki"

if [[ -f "$_f_dest" ]] && (( BACKUP )); then
    mv --force --no-copy "$_f_dest" "${_f_dest}.bak"
fi

msg "Generating UKI for kernel '%s' version '%s'" "$_kernel" "$KERNELVERSION"
msg2 "Kernel image: %s" "$_f_efi"
msg2 "Initramfs: %s" "$_f_initramfs"
msg2 "Microcodes: %s" "${MICROCODES[*]}"
msg2 "Cmdline: %s" "$_cmdline"

_ukify=(/usr/lib/systemd/ukify "$_f_efi" "${MICROCODES[@]}" "$_f_initramfs"
        --cmdline="$_cmdline" --uname="$KERNELVERSION"
        --secureboot-private-key="$_f_key" --secureboot-certificate="$_f_cert"
        --output="$_f_dest")

if [[ -v SPLASH ]]; then
    if [[ -f "$SPLASH" ]]; then
        _ukify+=(--splash="$SPLASH")
    else
        warning "Cannot find splash file '%s', ignoring" "$SPLASH"
    fi
fi

exec "${_ukify[@]}"
