#!/bin/bash

declare -r _f_config=%CONFIG%
declare -r _f_functions=functions

_f_key='' _f_cert=''
_f_efi='' _f_dest=''
_f_initramfs=''
_d_boot=''

_efitype=''
_kernel=''
_cmdline='' _uki=''

_ukify=''

declare -A EXTRA_SIGN

get_kernel() {
    local file kernel

    file="${1##*/}"

    for kernel in "${file#vmlinuz-}" "$file"; do
        if in_array "$kernel" "${KERNELS[@]}"; then
            printf '%s' "$kernel"
            return 0
        fi
    done

    return 1
}

enable_extra_sign() {
    local quiet="$1" units=()

    if (( SBUPDATE_EXTRA_SIGN )); then
        return 0
    fi

    systemctl --quiet disable "sbupdate@.path"
    systemctl --quiet stop "sbupdate@*.path"

    if (( ${#EXTRA_SIGN[@]} == 0 )); then
        return 0
    fi

    for file in "${!EXTRA_SIGN[@]}"; do
        local escaped

        escaped="$(systemd-escape --path "$file")"
        units+=("sbupdate@${escaped}.path")
    done

    if [[ "$quiet" ]]; then
        systemctl "$quiet" enable --now "${units[@]}"
    else
        systemctl enable --now "${units[@]}"
    fi
}

strnull() {
    if [[ "${*// }" ]]; then
        printf '%s' "$*"
    else
        printf '(null)'
    fi
}

cleanup() {
    exit "$1"
}

shopt -s extglob
# shellcheck disable=SC1090
. "$_f_functions"
shopt -u extglob

if [[ -t 1 ]]; then
    try_enable_color
fi

# shellcheck disable=SC1091,SC2016 source=sbupdate.conf
. <(sed '/^KERNELS=/a declare -A "${KERNELS[@]}"' "$_f_config") || die "Failed to read config file '%s'" "$_f_config"

[[ -d "$KEY_DIR" ]] || die "KEY_DIR '%s' doesn't exist or isn't a directory" "$KEY_DIR"

_f_key="$KEY_DIR/DB.key" _f_cert="$KEY_DIR/DB.crt"
[[ -f "$_f_key" && -f "$_f_cert" ]] || die "Cannot find Secure Boot key (DB.key) or cert (DB.crt) under KEY_DIR."

if [[ "$1" ]]; then
    enable_extra_sign --quiet
else
    if [[ -v KERNELDESTINATION ]]; then
        exit 0
    fi

    enable_extra_sign
    exit
fi

_f_efi="$1"
[[ -f "$_f_efi" ]] || die "EFI binary '%s' doesn't exist" "$_f_efi"

_efitype="$(bootctl kernel-identify "$_f_efi" 2>/dev/null)"
[[ "$_efitype" == "pe" ]] || die "'%s' isn't a valid EFI binary" "$_f_efi"

if (( SBUPDATE_EXTRA_SIGN )); then
    _f_dest="${EXTRA_SIGN["$_f_efi"]}"
    if [[ "$_f_dest" ]]; then
        sbsign --key "$_f_key" --cert "$_f_cert" --output "$_f_dest" "$_f_efi"
        exit
    else
        die "Requested for EXTRA_SIGN but file '%s' isn't listed" "$_f_efi"
    fi
fi

_d_boot="$(bootctl --print-boot-path 2>/dev/null)"
[[ -d "$_d_boot" ]] || die "Failed to locate ESP or XBOOTLDR"

_kernel="$(get_kernel "$_f_efi")"
if [[ ! "$_kernel" ]]; then
    msg "Kernel '%s' isn't configured in config '%s', ignoring" "$_f_efi" "$_f_config"
    exit 0
fi
_f_initramfs="$2"

set -e

declare -n _config="$_kernel"

if [[ ! -v "_config[uki-fallback]" ]]; then
    if [[ "$_f_initramfs" == *-fallback.img ]]; then
        exit 0
    fi

    if [[ -v "_config[uki]" ]]; then
        _uki="${_config[uki]}"
    else
        _uki="${_kernel#vmlinuz-}${UKI_SUFFIX}"
    fi
else
    _uki="${_config[uki-fallback]}"
fi

if [[ -v "_config[cmdline]" ]]; then
    _cmdline="${_config[cmdline]} $CMDLINE_ALWAYS"
else
    _cmdline="$CMDLINE_DEFAULT $CMDLINE_ALWAYS"
fi

mkdir -p "$_d_boot/$UKI_DIR"
_f_dest="$_d_boot/$UKI_DIR/$_uki"

if [[ -f "$_f_dest" ]] && (( BACKUP )); then
    mv --force --no-copy "$_f_dest" "${_f_dest}.bak"
fi

msg "Generating UKI for kernel '%s' version '%s'" "$_kernel" "$KERNELVERSION"
msg2 "Kernel image: %s" "$_f_efi"
msg2 "Initramfs: %s" "$_f_initramfs"
msg2 "Microcodes: %s" "$(strnull "${MICROCODES[*]}")"
msg2 "Cmdline: %s" "$(strnull "$_cmdline")"

_ukify=(/usr/lib/systemd/ukify "$_f_efi" "${MICROCODES[@]}" "$_f_initramfs"
        --cmdline="$_cmdline" --uname="$KERNELVERSION"
        --secureboot-private-key="$_f_key" --secureboot-certificate="$_f_cert"
        --output="$_f_dest")

if [[ -v SPLASH ]]; then
    if [[ -f "$SPLASH" ]]; then
        _ukify+=(--splash="$SPLASH")
    else
        warning "Cannot find splash file '%s', ignoring" "$SPLASH"
    fi
fi

exec "${_ukify[@]}"
